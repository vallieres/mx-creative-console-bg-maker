version: 2.1

orbs:
  go: circleci/go@3.0.2
  github-cli: circleci/github-cli@2.7.0

executors:
  go-executor:
    docker:
      - image: cimg/go:1.24
    resource_class: medium

  go-executor-large:
    docker:
      - image: cimg/go:1.24
    resource_class: large

  semgrep-executor:
    docker:
      - image: semgrep/semgrep:1.131.0-nonroot
    resource_class: medium

jobs:
  test:
    executor: go-executor
    steps:
      - checkout
      - go/load-mod-cache
      - go/mod-download
      - go/save-mod-cache
      - run:
          name: Run tests
          command: |
            go test -v ./...

  lint:
    executor: go-executor
    steps:
      - checkout
      - go/load-mod-cache
      - go/mod-download
      - go/save-mod-cache
      - restore_cache:
          keys:
            - golangci-lint-v2.1.6-{{ arch }}
      - run:
          name: Install golangci-lint
          command: |
            if [ ! -f ~/bin/golangci-lint ]; then
              mkdir -p ~/bin
              go install github.com/golangci/golangci-lint/v2/cmd/golangci-lint@v2.1.6
              cp $(go env GOPATH)/bin/golangci-lint ~/bin/
            fi
      - save_cache:
          key: golangci-lint-v2.1.6-{{ arch }}
          paths:
            - ~/bin/golangci-lint
      - run:
          name: Run linting
          command: |
            export PATH=~/bin:$PATH
            golangci-lint run

  build:
    executor: go-executor
    steps:
      - checkout
      - go/load-mod-cache
      - go/mod-download
      - go/save-mod-cache
      - run:
          name: Build binary
          command: |
            go build -v ./cmd/ccbm
      - persist_to_workspace:
          root: .
          paths:
            - ccbm

  release:
    executor: go-executor-large
    steps:
      - checkout
      - attach_workspace:
          at: .
      - go/load-mod-cache
      - go/mod-download
      - go/save-mod-cache
      - github-cli/install
      - run:
          name: Determine version
          command: |
            if git describe --tags --exact-match HEAD >/dev/null 2>&1; then
              VERSION=$(git describe --tags --exact-match HEAD)
            else
              LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
              COMMITS_SINCE_TAG=$(git rev-list --count ${LAST_TAG}..HEAD 2>/dev/null || echo "1")
              SHORT_SHA=$(git rev-parse --short HEAD)
              VERSION="${LAST_TAG}-${COMMITS_SINCE_TAG}-g${SHORT_SHA}"
            fi
            echo "export VERSION=${VERSION}" >> $BASH_ENV
      - run:
          name: Build multi-platform binaries
          command: |
            set -e
            mkdir -p dist
            
            echo "Building binaries..."
            
            # Build for Linux amd64
            echo "Building for Linux amd64..."
            GOOS=linux GOARCH=amd64 go build -ldflags "-X main.version=${VERSION}" -o dist/ccbm-linux-amd64 ./cmd/ccbm
            
            # Build for macOS amd64
            echo "Building for macOS amd64..."
            GOOS=darwin GOARCH=amd64 go build -ldflags "-X main.version=${VERSION}" -o dist/ccbm-darwin-amd64 ./cmd/ccbm
            
            # Build for macOS arm64
            echo "Building for macOS arm64..."
            GOOS=darwin GOARCH=arm64 go build -ldflags "-X main.version=${VERSION}" -o dist/ccbm-darwin-arm64 ./cmd/ccbm
            
            # Build for Windows amd64
            echo "Building for Windows amd64..."
            GOOS=windows GOARCH=amd64 go build -ldflags "-X main.version=${VERSION}" -o dist/ccbm-windows-amd64.exe ./cmd/ccbm
            
            # Verify all binaries were created
            for binary in dist/ccbm-*; do
              if [ ! -f "$binary" ]; then
                echo "Error: Failed to create $binary"
                exit 1
              fi
              echo "âœ“ Created $binary ($(stat -c%s "$binary" 2>/dev/null || stat -f%z "$binary") bytes)"
            done
      - run:
          name: Create GitHub release
          command: |
            # Get the latest commit message as release notes
            COMMIT_MSG=$(git log -1 --pretty=%B)
            
            # Only create release if this is a tag push or main branch
            if git describe --tags --exact-match HEAD >/dev/null 2>&1; then
              echo "Creating release for tag: ${VERSION}"
            else
              echo "Creating pre-release for commit: ${VERSION}"
            fi
            
            # Create git tag if it doesn't exist
            if ! git describe --tags --exact-match HEAD >/dev/null 2>&1; then
              git tag $VERSION
              git push origin $VERSION
            fi
            
            # Create GitHub release with binaries
            RELEASE_FLAGS="--title \"Release $VERSION\" --notes \"$COMMIT_MSG\""
            if [[ $VERSION == *"-"* ]]; then
              RELEASE_FLAGS="$RELEASE_FLAGS --prerelease"
            fi
            
            gh release create $VERSION $RELEASE_FLAGS \
              dist/ccbm-linux-amd64 \
              dist/ccbm-darwin-amd64 \
              dist/ccbm-darwin-arm64 \
              dist/ccbm-windows-amd64.exe
      - store_artifacts:
          path: dist/
          destination: binaries

workflows:
  version: 2
  ci:
    jobs:
      # Run tests and linting in parallel for all branches
      - test
      - lint
      
      # Build depends on both test and lint passing
      - build:
          requires:
            - test
            - lint
      
      # Release only runs on main branch and depends on build
      - release:
          requires:
            - build
          filters:
            branches:
              only: main
